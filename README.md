# Redis-Exploitation-Toolkit
**Redis Exploitation Toolkit** - A tool to pwn Redis server for FUN and PROFIT!

<pre>
                _._                                                               
           _.-``__ ''-._                                                          
      _.-``    `.  `_.  ''-._             RET | Redis Exploitation Toolkit v1.0   
  .-`` .-```.  ```\/    _.,_ ''-._          by Shivam Bathla <@_shivambathla>     
 (    '      ,       .-`  | `,    )                                               
 |`-._`-...-` __...-.``-._|'` _.-'|                                               
 |    `-._   `._    /     _.-'    |                                               
  `-._    `-._  `-./  _.-'    _.-'       Because Redis is more than a database ;) 
 |`-._`-._    `-.__.-'    _.-'_.-'|                                               
 |    `-._`-._        _.-'_.-'    |                                               
  `-._    `-._`-.__.-'_.-'    _.-'                                                
 |`-._`-._    `-.__.-'    _.-'_.-'|                                               
 |    `-._`-._        _.-'_.-'    |                                               
  `-._    `-._`-.__.-'_.-'    _.-'                                                
      `-._    `-.__.-'    _.-'                                                    
          `-._        _.-'                                                        
              `-.__.-'    
</pre>


# Modes of Operation

This tool can operate under two modes:
- [interactive](#interactive-mode)
- [automated](#automated-mode)


# <a name="interactive-mode"></a>Interactive Mode

By default, you get an interactive shell where you can enter the names of the attack modules and their sub-modules and execute the currently available attacks.  

With the interactive module, you get a lot of fun stuff essentially for free! These include:  

- An embedded shell to execute system commands,
- An embedded redis shell to execute commands on the remote Redis server,
- Help messages and information on all the attack modules,
- List of available modules, sub-modules and the commands in them,
- Ability to run individual attacks without having to go through all the other available attacks.


# <a name="automated-mode"></a>Automated Mode

You need to specify `-a` or `--auto` flag to start the tool in automated mode.  

In this mode, all the attacks are launched one after the other. Currently the attack sequence is decided manually. All the attack modules are arranged in such a manner that the attacks to be executed first are placed above those that are to be executed later in the exploitation process.  

All you need to do is answer some questions (typically yes/no) or supply the wordlist. If nothing is supplied, the default options are taken into consideration and thus you can supply a number of `enter` commands to run it in a fully automated fashion.  


# <a name="attack-modules"></a>Attack Modules

Currently 3 attack modules are available:  

- **[enum:](#enum)** To perform enumeration attacks including Keys enum, redis users enum (Auth), and ACL entries enum.  
- **[exec:](#exec)** To perform attacks resulting in command execution via three techniques: Webshell, SSH, Crontab.  
- **[module_load:](#module_load)** To load a malicious module. Additionally, we have provided a pre-compiled attack module that facilitates arbitrary command execution, and also the payloads for bind shell and reverse shell.  

## <a name="enum"></a>enum

Use this attack module to perform a variety of enumeration attacks.  

Currently available enum attacks are:  

- [acl](#enum-acl)
- [auth](#enum-auth)
- [keys](#enum-keys)
- [misc](#enum-misc)


### <a name="enum-acl"></a>acl

Under this sub-module, we have the following ACL-related attacks currently available:  

- **retrieve_acl_entries:** Retrieves the ACL entries from a connected Redis instance.
- **crack_acl_password_hashes:** Cracks the ACL password hashes retrieved from the ACL entries. JTR is used to perform the hash cracking.  
- **retrieve_acl_logs:** Retrieves the ACL logs. This information is valuable for both Red- and Blue-teams! For instance, a Red-teamer can harvest usernames (helpful to perform `AUTH` attacks) from these logs whereas a Blue teamer can find the bruteforce attempts for a user from these logs.  


### <a name="enum-auth"></a>auth

Under this sub-module, we have the following AUTH-related attacks currently available:  

- **auth_existence_check:** Checks if the Redis server requires authentication or is open for anyone to connect.  
- **crack_weak_auth:** Performs a dictionary attack against the Redis server.  


### <a name="enum-keys"></a>keys

Under this sub-module, we have the following KEYS-related attacks currently available:  

- **keys_enum:** Performs key enumeration attack.  

For the `keys_enum` attack, you can provide a `KEYS_FILE` file containing the wordlist path for the parts of the keys. This file can be set in the `config/settings.py` file as well.  

Another important thing to note is the depth (or the `levels` parameter).  

Here are some example keys and their depths are indicated in brackets:  

```
products                 (1)
products:all             (2)
products:mac:101         (3)
products:mac:charger:102 (4)
```

As the depth/levels increase, the time it takes to generate the keys increases as well and so does the resources required to compute that many keys. Thus it is advisable to use a lower number whenever possible.  

3 seems to be a sane default and you should keep it in the range of 2-4. That would be sufficient enough to cover most (if not all) the keys.  

One more thing to note is that it's not the depth but the keys file that would be more important. If the keys file doesn't contains the parts that exist in a Redis server, then tuning the level won't help. As simple as that.  


### <a name="enum-misc"></a>misc

Under this sub-module, we have the following miscellaneous attacks currently available:  

- **monitor_server_commands:** This will run the `MONITOR` command and thus we will get all the commands sent to the Redis server from the instance this command is run.  

Of importance is the fact that this blocks the client and moreover, this command takes up a lot of server resources. And therefore it is quite noisy!  


## <a name="exec"></a>exec

Use this attack module to perform a variety of attacks resulting in command execution.    

Currently available exec attack techniques are:  

- [webshell](#exec-webshell)
- [ssh](#exec-ssh)
- [crontab](#exec-crontab)

All of these attack techniques require youto have the permissions to execute the following commands on the Redis Server:  

- CONFIG SET
- CONFIG GET (not mandatory but good to have)
- SAVE
- FLUSHALL/FLUSHDB (not mandatory but good to have)
- SET

All of the attack techniques leverage the RDB (dump) file to implant the payload in the WEBROOT directory or `.ssh/authorized_keys` file or the the crontabs directory.  


### <a name="exec-webshell"></a>webshell

Use this technique to gain command execution by saving a webshell payload in the WEBROOT directory.  

This techique only works if:

- A webserver is running (that's common sense!)
- You know (or can guess) the WEBROOT directory (that's easy but not always...)
- You have access to the commands specified under the [`exec`](#exec) module
- You have permissions to write to the WEBROOT directory. If the payload cannot be saved (because of missing permissions), then the attack won't work...


### <a name="exec-ssh"></a>ssh

Use this technique to gain command execution by saving attacker's SSH key in the `.ssh/authorized_keys` file of the user you wish to attack.  

This techique only works if:

- SSH service is running (that's common sense!)
- You know (or can guess) the path to the SSH directory of the user you wish to attack (that's easy but not always...)
- You have access to the commands specified under the [`exec`](#exec) module
- You have permissions to write to the SSH directory of the victim user. If the SSH keys cannot be saved (because of missing permissions), then the attack won't work...


### <a name="exec-crontab"></a>crontab

Use this technique to gain command execution by saving your payload the crontabs directory.  

This techique only works if:

- Cron service is running (that's common sense!)
- You know (or can guess) the path to the crontabs directory (that should be easy as there are only a handful of options...)
- You have access to the commands specified under the [`exec`](#exec) module
- You have permissions to write to the crontabs directory. If the cron job cannot be saved (because of missing permissions), then the attack won't work...
- In addition to all this, the file permissions as well as the file format must be correct! In Debian-based distros, the crontab file is expected to be in proper format, else the file is not executed. And in this case, the dump file is bound to have some binary gibberish in it that corrupts the crontabs directory!  


## <a name="module_load"></a>module_load

Use this attack module to perform attack to load a malicious Redis module.  

Currently this module contains one attack techique:  

- [load_malicious_module](#module_load-load_malicious_module)


### <a name="module_load-load_malicious_module"></a>load_malicious_module

This attack will load a malicious Redis module allowing you to:  

- Execute arbitrary commands (`SYS.EXEC`)
- Obtain a reverse shell (`SYS.REVSHELL`)
- Start a bind shell (`SYS.BINDSHELL`)


Use this attack when:  

- You have a Redis module uploaded on the Redis server host
- The uploaded module has execute permissions
- Redis server (the privileges with which it is running) has permissions to access the uploaded module


An important point to note is that if a module with the same name already exists on the target Redis server, the current action is to unload that module and load the supplied module. Only reason being that if you are running this attack, then we assume that you wish to load the module (and it is not currently loaded or is updated). And for that reason, we unload the existing module and load the specified module.  