from .common import get_assume_defaults_value, read_file, \
    get_cached_db_connection, KEYS_FILE, DEFAULT_KEY_SEPARATOR


AVAILABLE_ATTACKS = [
    "keys_enum"
]



def rec_keys_enum_help():
    return "\nA recursive function to create a combination of\n" \
    "the keys using `:` as the separator.\n" \
    "By default it goes to the depth of 2 levels only!\n" \
    "Increaing the depth would increase the time it takes\n" \
    "to run this code and that would be more CPU intensive\n" \
    "as well. So it's best to keep the level value upto 3\n" \
    "or 4 at max. Keys having more than 4 words in a\n" \
    "namespace are rare. Besides being quite noisy, its\n" \
    "quite expensive to conduct such attacks.\n"



# It' a tail-recursive function now!
# And it's quite better than what it used to be...
def rec_keys_enum(redis, key_space, level_words, sep = ":", levels = 2):

    if levels == 0:
        return

    new_words = []

    for prefix in key_space:
        for suffix in level_words:
            new_words.append(f"{prefix}{sep}{suffix}")
            exists = redis.exists(new_words[-1])

            if exists:
                print (new_words[-1])

        # level_words must be empty array!
        if len(new_words) == 0:
            exists = redis.exists(prefix)

            if exists:
                print (prefix)

    if len(new_words) == 0:
        new_words = key_space

    return rec_keys_enum(redis, key_space, new_words, ":", levels - 1)



def keys_enum_help():
    return "\nEnumerates the keys available on a Redis server.\n"



def keys_enum():

    redis = get_cached_db_connection()

    assume_defaults = get_assume_defaults_value()

    keys_file = KEYS_FILE
    levels = 3

    if not assume_defaults:
        keys_file = input(f"\nSpecify keys file (default='{KEYS_FILE}') ") or keys_file
        levels = input("\nConfigure depth (default = 3): ") or levels

    try:
        levels = int(levels)
    except:
        print (f"Invalid depth: {levels}\n\nContinuing with the default depth of 3...\n")
        levels = 3


    key_space = read_file(keys_file).split("\n")

    if len(key_space) ** levels > 1000000000:
        print("Warning: This will take a lot of time!")

        assume_defaults = get_assume_defaults_value()

        proceed = "N"

        if not assume_defaults:
            proceed = input("\nAre you sure you wish to continue? (default='no') [y/N] ") or proceed

        if proceed.lower() != "y":
            print("\nSkipping Key Enumeration.\n")
            return

    separator = DEFAULT_KEY_SEPARATOR

    print ("\n[*] Discovered Keys\n")
    rec_keys_enum(redis, key_space, [], separator, levels)
    print ()



def get_available_attacks():
    return AVAILABLE_ATTACKS



def perform_keys_attack(attack_name):
    if attack_name in AVAILABLE_ATTACKS:
        globals()[attack_name]()
    else:
        print ("\n[-] Invalid attack name.\n")



if __name__ == "__main__":
    keys_enum()