from .common import get_assume_defaults_value, read_file, get_cached_db_connection, KEYS_FILE


AVAILABLE_ATTACKS = [
    "keys_enum"
]



def rec_keys_enum_help():
    return "\nA recursive function to create a combination of\n" \
    "the keys using `:` as the separator.\n" \
    "By default it goes to the depth of 2 levels only!\n" \
    "Increaing the depth would increase the time it takes\n" \
    "to run this code and that would be more CPU intensive\n" \
    "as well. So it's best to keep the level value upto 3\n" \
    "or 4 at max. Keys having more than 4 words in a\n" \
    "namespace are rare. Besides being quite noisy, its\n" \
    "quite expensive to conduct such attacks.\n"



def rec_keys_enum(redis, words, sep = ":", levels = 2, recursing = False):

    # print ("words:", words)
    # print ("sep:", sep)
    # print ("levels:", levels)
    # print ("recursing:", recursing)

    if not recursing:
        print ("\n[Discovered Keys]")

        if len(words) ** levels > 1000000000:
            print("Warning: This will take a lot of time!")

            assume_defaults = get_assume_defaults_value()

            proceed = "N"

            if not assume_defaults:
                proceed = input("\nAre you sure you wish to continue? (default='no') [y/N] ") or proceed

            if proceed.lower() != "y":
                print("\nSkipping Key Enumeration.\n")
                return

    if levels == 1:
        for word in words:
            exists = redis.exists(word)
            if exists:
                print (f"{word}: {exists}")
        return words

    level_words = rec_keys_enum(redis, words, ":", levels - 1, recursing = True)

    new_words = []

    for word_prefix in words:
        for word_suffix in level_words:
            new_words.append(f"{word_prefix}{sep}{word_suffix}")
            exists = redis.exists(new_words[-1])
            if exists:
                print (f"{new_words[-1]}")

    return new_words



def keys_enum_help():
    return "\nIt's a wrapper around the rec_keys_enum function\n" \
    "which does the real work of creating keys and checking\n" \
    "for their existence.\n"



def keys_enum():

    redis = get_cached_db_connection()

    assume_defaults = get_assume_defaults_value()

    keys_file = KEYS_FILE
    levels = 3

    if not assume_defaults:
        keys_file = input(f"\nSpecify keys file (default='{KEYS_FILE}') ") or keys_file
        levels = input("\nConfigure depth (default = 3): ") or levels

    try:
        levels = int(levels)
    except:
        print (f"Invalid depth: {levels}\n\nContinuing with the default depth of 3...\n")
        levels = 3

    rec_keys_enum(redis, read_file(keys_file).split("\n"), sep = ":", levels = levels, recursing = False)
    print ()



def get_available_attacks():
    return AVAILABLE_ATTACKS



def perform_keys_attack(attack_name):
    if attack_name in AVAILABLE_ATTACKS:
        globals()[attack_name]()
    else:
        print ("\n[-] Invalid attack name.\n")



if __name__ == "__main__":
    keys_enum()