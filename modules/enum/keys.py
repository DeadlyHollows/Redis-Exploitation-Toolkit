from .common import get_assume_defaults_value, \
        read_file, get_cached_db_connection

from .common import settings


AVAILABLE_ATTACKS = [
    "keys_enum"
]



def get_key_value(redis, key):

    key_type = redis.type(key)
    key_encoding = redis.object("encoding", key)

    # Currently only adding basic data types
    # Can extend it later...
    # Most of the interesting stuff might be found in these data types itself

    if key_type == "string" and key_encoding in [ "embstr", "int", "raw" ]:
            # String
            return redis.get(key)

    elif key_type == "list" and key_encoding in [ "ziplist", "hashtable" ]:
        # List
        return redis.lrange(key, 0, -1)

    elif key_type == "set" and key_encoding in [ "intset", "hashtable" ]:
        # Set
        return redis.smembers(key)

    elif key_type == "hash" and key_encoding in [ "ziplist", "hashtable" ]:
        # Hash
        return redis.hgetall(key)

    elif key_type == "zset" and key_encoding in [ "ziplist", "skiplist" ]:
        # Sorted set
        return redis.zrangebyscore(key, min = "-inf", max = "+inf", withscores = True)



def rec_keys_enum_help():
    return "\nA recursive function to create a combination of\n" \
    "the keys using `:` as the separator.\n" \
    "By default it goes to the depth of 2 levels only!\n" \
    "Increaing the depth would increase the time it takes\n" \
    "to run this code and that would be more CPU intensive\n" \
    "as well. So it's best to keep the level value upto 3\n" \
    "or 4 at max. Keys having more than 4 words in a\n" \
    "namespace are rare. Besides being quite noisy, its\n" \
    "quite expensive to conduct such attacks.\n"



# It' a tail-recursive function now!
# And it's quite better than what it used to be...
def rec_keys_enum(redis, key_space, level_words, sep = ":", levels = 2):

    if levels == 0:
        return

    new_words = []

    for prefix in key_space:
        for suffix in level_words:
            new_words.append(f"{prefix}{sep}{suffix}")

            exists = redis.exists(new_words[-1])

            if exists:
                print(new_words[-1])
                print ("  type:", redis.type(new_words[-1]))
                print ("  encoding:", redis.object("encoding", new_words[-1]))
                print ("  value:", get_key_value(redis, new_words[-1]), "\n")

        # level_words must be empty array!
        if len(new_words) == 0:
            exists = redis.exists(prefix)

            if exists:
                print(prefix)
                print ("  type:", redis.type(prefix))
                print ("  encoding:", redis.object("encoding", prefix))
                print ("  value:", get_key_value(redis, prefix), "\n")

    if len(new_words) == 0:
        new_words = key_space

    return rec_keys_enum(redis, key_space, new_words, ":", levels - 1)



def keys_enum_help():
    return "\nEnumerates the keys available on a Redis server.\n"



def keys_enum(redis):

    assume_defaults = get_assume_defaults_value()

    keys_file = settings.KEYS_FILE
    levels = 3

    if not assume_defaults:
        keys_file = input(f"\nSpecify keys file (default='{settings.KEYS_FILE}') ") or keys_file
        levels = input("\nConfigure depth (default = 3): ") or levels

    try:
        levels = int(levels)
    except:
        print(f"Invalid depth: {levels}\n\nContinuing with the default depth of 3...\n")
        levels = 3


    key_space = read_file(keys_file).split("\n")

    if len(key_space) ** levels > 1000000000:
        print("Warning: This will take a lot of time!")

        assume_defaults = get_assume_defaults_value()

        proceed = "N"

        if not assume_defaults:
            proceed = input("\nAre you sure you wish to continue? (default='no') [y/N] ") or proceed

        if proceed.lower() != "y":
            print("\nSkipping Key Enumeration.\n")
            return False

    separator = settings.DEFAULT_KEY_SEPARATOR

    print("\n[*] Discovered Keys\n")

    rec_keys_enum(redis, key_space, [], separator, levels)
    print()

    return True



def get_available_attacks():
    return AVAILABLE_ATTACKS



def perform_keys_attack(attack_name, redis):
    if attack_name in AVAILABLE_ATTACKS:
        globals()[attack_name](redis)
    else:
        print("\n[-] Invalid attack name.\n")



if __name__ == "__main__":
    redis = get_cached_db_connection()
    keys_enum(redis)