# TODO:
# 
# 1. Add interactive shell to execute commands
# 2. Add options using argparse
# 3. Add DB support using SQLite
# 4. Add documentation, comments and help messages
# 5. Create a banner and logo

from importlib import import_module

from pprint import pprint
from pkgutil import iter_modules

import readline
import shlex
from sys import exit

from helper.utils import execute_command_with_output, execute_redis_command, strip_quotes_from_entries



REDIS_PROMPT = "redis>"

AVAILABLE_MODULES = [name for _, name, _ in iter_modules(["modules"])]



def list_available_items(items):

    idx = 1
    for item in items:
        if isinstance(item, dict):
            print (f"{idx} - {list(item.keys())[0]}")
        else:
            print (f"{idx} - {item}")
        idx += 1



def exists_in_attack_module(available_attacks, sub_attack):

    for attack in available_attacks:
        if isinstance(attack, dict):
            if list(attack.keys())[0] == sub_attack:
                return attack[list(attack.keys())[0]]
        else:
            if sub_attack in attack:
                return True

    return False



def handle_shell_command(unconsumed_parts, prompt_sign):

    if unconsumed_parts[0] in ["exit", "quit"]:
        prompt_sign = ">"
        return prompt_sign

    # Hand it over to the shell.
    output = execute_command_with_output(" ".join(unconsumed_parts))
    print (output.decode(encoding = "utf-8", errors = "replace"))
    return prompt_sign



def handle_redis_command(unconsumed_parts, prompt_sign):

    if unconsumed_parts[0] in ["exit", "quit"]:
        prompt_sign = ">"
        return prompt_sign

    # Run Redis command.
    try:
        unconsumed_parts = strip_quotes_from_entries(unconsumed_parts)
        # print ("unconsumed_parts:", unconsumed_parts)
        # output = execute_redis_command(" ".join(unconsumed_parts))
        output = execute_redis_command(*unconsumed_parts)
        pprint(output)
    except Exception as e:
        # print ("INside EXceptioN!")
        print (e)

    return prompt_sign



def get_attack_module_help_message(module_name):
    return import_module(f"modules.{module_name}").get_attack_module_help_message()



def move_prompt_one_step_up(prompt):

    prompt = "/".join(prompt[1:-1].split("/")[:-1])
    if prompt != "":
        prompt = f"[{prompt}]"

    return prompt



def handle_attack_sub_commands(cmd, unconsumed_parts, prompt, available_attacks):

    if len(unconsumed_parts) == 0:
        prompt = f"[{cmd}]"
        return prompt

    sub_cmd = unconsumed_parts[0]
    sub_cmd = sub_cmd.lower()
    unconsumed_parts = unconsumed_parts[1:]

    # print ("=> sub_cmd:", sub_cmd)
    # print ("=> unconsumed_parts:", unconsumed_parts)

    if len(unconsumed_parts) == 0:

        if sub_cmd in ["help", "info"]:
            print (get_attack_module_help_message(cmd))

        elif sub_cmd == "list":
            print (f"\n[*] Available {cmd} sub-commands:")
            list_available_items(available_attacks[cmd])
            print ()

        elif sub_cmd in available_attacks[cmd] or \
            (isinstance(available_attacks[cmd][0], dict) and \
            exists_in_attack_module(available_attacks[cmd], sub_cmd)):
            prompt = f"[{cmd}/{sub_cmd}]"


        else:
            print (f"\n[-] Invalid sub-command specified: {sub_cmd}\n\nCurrently available sub-commands:")
            # list_available_items(available_attacks[cmd][sub_cmd])
            if isinstance(available_attacks[cmd], dict) and sub_cmd in available_attacks[cmd]:
                list_available_items(available_attacks[cmd][sub_cmd])
            else:
                list_available_items(available_attacks[cmd])

            print ()


    elif len(unconsumed_parts) == 1 and \
        (sub_cmd in available_attacks[cmd] or \
        isinstance(available_attacks[cmd][0], dict)):

        sub_sub_cmd = unconsumed_parts[0].lower()

        # print ("=> available_attacks[cmd]:", available_attacks[cmd])
        # print ("=> exists_in_attack_module:", exists_in_attack_module(available_attacks[cmd], sub_cmd))
        # print ("=> sub_cmd:", sub_cmd)
        # print ("=> sub_sub_cmd:", sub_sub_cmd)

        if sub_sub_cmd in ["help", "info"]:
            # print (available_attacks)
            # if isinstance(available_attacks[cmd], dict) and sub_cmd in available_attacks[cmd]:
            if isinstance(available_attacks[cmd], list):
                sub_attacks = exists_in_attack_module(available_attacks[cmd], sub_cmd)
                print ("\n[*] Available sub-commands:")

                if sub_attacks == True:
                    print (getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"{sub_cmd}_help")())
                elif sub_attacks:
                    list_available_items(sub_attacks)
                    print ()
                else:
                    list_available_items(available_attacks[cmd][sub_cmd])

            else:
                # list_available_items(available_attacks[cmd])
                print ("\n[*] Information:")
                print (getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"{sub_cmd}_help")())

        elif sub_sub_cmd in ["run", "exploit"] and \
            isinstance(available_attacks[cmd], list) and \
            not isinstance(available_attacks[cmd][0], dict):
            # Execute the attack!
            try:
                getattr(import_module(f"modules.{cmd}.{cmd}"), f"perform_{cmd}_attack")(sub_cmd)
            except KeyboardInterrupt as e:
                print ("\n[*] Stopping the attack...\n")

        elif isinstance(available_attacks[cmd], dict) and \
            sub_cmd in available_attacks[cmd] and \
            sub_sub_cmd in available_attacks[cmd][sub_cmd]:
            prompt = f"[{cmd}/{sub_cmd}/{sub_sub_cmd}]"

        elif isinstance(available_attacks[cmd], list) and \
            isinstance(available_attacks[cmd][0], dict) and \
            sub_sub_cmd in exists_in_attack_module(available_attacks[cmd], sub_cmd):
            prompt = f"[{cmd}/{sub_cmd}/{sub_sub_cmd}]"

        else:
            if unconsumed_parts[0] == "list":
                print ("\n[*] Currently available sub-commands:")
            else:
                print (f"\n[-] Invalid sub-command specified: {unconsumed_parts[0]}\n")

            if isinstance(available_attacks[cmd], dict) and \
            sub_cmd in available_attacks[cmd]:
                list_available_items(available_attacks[cmd][sub_cmd])

            elif isinstance(available_attacks[cmd][0], dict):
                sub_attacks = exists_in_attack_module(available_attacks[cmd], sub_cmd)

                if sub_attacks:
                    list_available_items(sub_attacks)


            else:
                print ("- help/info")
                print ("- list")
                print ("- run/exploit")
                print ("- shell")
                print ("- redis-shell")
                print ("- back/up")
                print ("- reset")

            print ()


    elif len(unconsumed_parts) == 2 and \
        (isinstance(available_attacks[cmd], dict) or \
        isinstance(available_attacks[cmd][0], dict)):

        # print (exists_in_attack_module(available_attacks[cmd], sub_cmd))

        sub_sub_cmd = unconsumed_parts[0].lower()
        unconsumed_parts = [_.lower() for _ in unconsumed_parts[1:]]

        # print (sub_sub_cmd, unconsumed_parts)

        if unconsumed_parts[0] in ["help", "info"]:

            if isinstance(available_attacks[cmd], list) and \
                sub_cmd in available_attacks[cmd] and \
                isinstance(available_attacks[cmd][sub_cmd], list) and \
                sub_sub_cmd in available_attacks[cmd][sub_cmd]:
                print ("\nAvailable sub-commands:")
                list_available_items(available_attacks[cmd][sub_cmd][sub_sub_cmd])
                print ()

            else:
                print ("\nInformation:")
                print (getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"{sub_sub_cmd}_help")())


        elif unconsumed_parts[0] in ["run", "exploit"]:
            # Execute the attack!
            try:
                getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"perform_{sub_cmd}_attack")(sub_sub_cmd)
            except KeyboardInterrupt as e:
                print ("\n[*] Stopping the attack...\n")

        else:

            if unconsumed_parts[0] == "list":
                print ("\n[*] Currently available sub-commands:")
            else:
                print (f"\n[-] Invalid sub-command specified: {unconsumed_parts[0]}\n")

            # TODO: Display allowed sub-commands...
            if isinstance(available_attacks[cmd], list) and \
            sub_cmd in available_attacks[cmd] and \
            isinstance(available_attacks[cmd][sub_cmd], list) and \
            sub_sub_cmd in available_attacks[cmd][sub_cmd]:
                list_available_items(available_attacks[cmd][sub_cmd])

            else:
                print ("- help/info")
                print ("- list")
                print ("- run/exploit")
                print ("- shell")
                print ("- redis-shell")
                print ("- back/up")
                print ("- reset")

            print ()


    else:
        if sub_cmd in available_attacks[cmd]:
            print (f"\n[-] Invalid sub-command specified.\n\nCurrently available sub-commands:")
            print(f"- {cmd} {sub_cmd}")
            print(f"- {cmd} {sub_cmd} help")
            print(f"- {cmd} {sub_cmd} info")

        else:
            print (f"\n[-] Invalid sub-command specified: {sub_cmd}\n\nCurrently available sub-commands:")
            print ("OYE1!")
            list_available_items(available_attacks[cmd])

        print ()

    return prompt



def launch_in_interactive_mode():

    print("\nTo get help, enter `help`.")
    print("To get help on a specific module, enter `help <Module Name>`.\n")

    prompt = ""
    prompt_sign = ">"

    while True:
        try:
            unconsumed_parts = shlex.split(input(f"{prompt}{prompt_sign} "), posix = False)
        except KeyboardInterrupt as e:
            exit(0)
        except Exception as e:
            exit(0)


        if len(unconsumed_parts) > 0:
            if unconsumed_parts[0] == "shell":
                unconsumed_parts = unconsumed_parts[1:]
                prompt_sign = "$"

            elif unconsumed_parts[0] == "redis-shell":
                unconsumed_parts = unconsumed_parts[1:]
                prompt_sign = REDIS_PROMPT

        if prompt_sign == "$":
            if len(unconsumed_parts) == 0:
                continue

            prompt_sign = handle_shell_command(unconsumed_parts, prompt_sign)
            continue

        elif prompt_sign == REDIS_PROMPT:
            if len(unconsumed_parts) == 0:
                continue

            prompt_sign = handle_redis_command(unconsumed_parts, prompt_sign)
            continue

        if len(unconsumed_parts) == 0:
            continue

        unconsumed_parts[0] = unconsumed_parts[0].lower()

        if unconsumed_parts[0] in ["exit", "quit", "bye"]:
            break

        elif unconsumed_parts[0] == "reset":
            prompt = ""
            continue

        elif unconsumed_parts[0] in ["back", "up"]:
            prompt = move_prompt_one_step_up(prompt)
            continue

        if prompt != "":
            module_hierarchy = prompt[1:-1].split("/")
            cmd = module_hierarchy[0]
            if len(module_hierarchy) > 1:
                unconsumed_parts = module_hierarchy[1:] + unconsumed_parts
        else:
            cmd = unconsumed_parts[0]
            unconsumed_parts = unconsumed_parts[1:]

        if cmd == "help":
            print ("\n[*] Available Commands:")
            print ("- help")
            print ("- info/list")
            print ("- shell")
            print ("- redis-shell")

        if cmd in ["help", "info", "list"]:
            # Length would give the unconsumed unconsumed_parts
            if len(unconsumed_parts) == 0:
                # show_help()
                print ("\n[*] Available attack modules:")
                list_available_items(AVAILABLE_MODULES)

                print("\nEnter the module name to proceed: \n")


            elif len(unconsumed_parts) == 1:
                sub_cmd = unconsumed_parts[0]
                sub_cmd = sub_cmd.lower()

                # show info on the sub_cmd
                if sub_cmd in AVAILABLE_MODULES:
                    print (get_attack_module_help_message(sub_cmd))

                else:
                    print (f"\n[-] Invalid module name specified: {sub_cmd}\n")
                    print ("[*] Currently available modules:")
                    list_available_items(AVAILABLE_MODULES)
                    print ()

            else:
                print ("\n[-] Unexpected number of arguments:")
                print ("Use `help` or `info` to list all the available modules.")
                print ("Use `help <Module Name>` or `info <Module Name>` to get info about the specified module.\n")


        elif cmd in AVAILABLE_MODULES:
            available_attacks = import_module(f"modules.{cmd}").AVAILABLE_ATTACKS
            prompt = handle_attack_sub_commands(cmd, unconsumed_parts, prompt, available_attacks)

        else:
            print(f"\n[-] Invalid module name specified: {cmd}\n")
            print ("[*] Currently available modules:")
            list_available_items(AVAILABLE_MODULES)
            print ()




if __name__ == "__main__":
    launch_in_interactive_mode()