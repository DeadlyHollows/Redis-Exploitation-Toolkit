from importlib import import_module

from pprint import pprint
from pkgutil import iter_modules

import readline
import shlex
import sys
from os import get_terminal_size

from helper.utils import execute_command_with_output, execute_redis_command, strip_quotes_from_entries



REDIS_PROMPT = "redis>"

AVAILABLE_ATTACK_MODULES = [name for _, name, _ in iter_modules(["modules"])]



def list_available_items(items):

    idx = 1
    for item in items:
        if isinstance(item, dict):
            print (f"{idx} - {list(item.keys())[0]}")
        else:
            print (f"{idx} - {item}")
        idx += 1



def list_available_general_commands(with_header = True):

    if with_header:
        print ("\n[*] Available general commands:")

    print ("- help")
    print ("- info / list")
    print ("- run / exploit")
    print ("- shell / sh")
    print ("- redis-shell / rsh")
    print ("- back <N> / up <N>")
    print ("- reset\n")



def exists_in_attack_module(available_attacks, sub_attack):

    for attack in available_attacks:
        if isinstance(attack, dict):
            if list(attack.keys())[0] == sub_attack:
                return attack[list(attack.keys())[0]]
        else:
            if sub_attack in attack:
                return True

    return False



def handle_shell_command(unconsumed_parts, prompt_sign):

    if unconsumed_parts[0] in ["exit", "quit"]:
        prompt_sign = ">"
        return prompt_sign

    # Hand it over to the shell.
    output = execute_command_with_output(" ".join(unconsumed_parts))
    print (output.decode(encoding = "utf-8", errors = "replace"))
    return prompt_sign



def handle_redis_command(unconsumed_parts, prompt_sign):

    if unconsumed_parts[0] in ["exit", "quit"]:
        prompt_sign = ">"
        return prompt_sign

    # Run Redis command.
    try:
        unconsumed_parts = strip_quotes_from_entries(unconsumed_parts)
        output = execute_redis_command(*unconsumed_parts)

        if isinstance(output, str):
            print ()
            print (output)
        else:
            pprint(output, width = (get_terminal_size().columns * 9) // 10, compact = True)

    except Exception as e:
        print (e)

    return prompt_sign



def get_attack_module_help_message(module_name):
    return import_module(f"modules.{module_name}").get_attack_module_help_message()



def adjust_prompt_level(prompt, level):

    prompt = "/".join(prompt[1:-1].split("/")[:-level])
    if prompt != "":
        prompt = f"[{prompt}]"

    return prompt



def handle_attack_sub_commands(cmd, unconsumed_parts, prompt, available_attacks):

    if len(unconsumed_parts) == 0:
        prompt = f"[{cmd}]"
        return prompt

    sub_cmd = unconsumed_parts[0]
    sub_cmd = sub_cmd.lower()
    unconsumed_parts = unconsumed_parts[1:]

    if len(unconsumed_parts) == 0:

        if sub_cmd in ["help", "info"]:
            print (get_attack_module_help_message(cmd))

        elif sub_cmd == "list":
            print (f"\n[*] Available {cmd} sub-commands:")
            list_available_items(available_attacks[cmd])
            list_available_general_commands()

        elif sub_cmd in available_attacks[cmd] or \
            (isinstance(available_attacks[cmd][0], dict) and \
            exists_in_attack_module(available_attacks[cmd], sub_cmd)):
            prompt = f"[{cmd}/{sub_cmd}]"


        else:
            print (f"\n[-] Invalid sub-command specified: {sub_cmd}\n\n[*] Available sub-commands:")
            if isinstance(available_attacks[cmd], dict) and sub_cmd in available_attacks[cmd]:
                list_available_items(available_attacks[cmd][sub_cmd])
            else:
                list_available_items(available_attacks[cmd])

            list_available_general_commands()


    elif len(unconsumed_parts) == 1 and \
        (sub_cmd in available_attacks[cmd] or \
        isinstance(available_attacks[cmd][0], dict)):

        sub_sub_cmd = unconsumed_parts[0].lower()

        if sub_sub_cmd in ["help", "info"]:
            if isinstance(available_attacks[cmd], list):
                sub_attacks = exists_in_attack_module(available_attacks[cmd], sub_cmd)
                print ("\n[*] Available sub-commands:")

                if sub_attacks == True:
                    print (getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"{sub_cmd}_help")())
                elif sub_attacks:
                    list_available_items(sub_attacks)
                else:
                    list_available_items(available_attacks[cmd][sub_cmd])

                list_available_general_commands()

            else:
                print ("\n[*] Information:")
                print (getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"{sub_cmd}_help")())

        elif sub_sub_cmd in ["run", "exploit"] and \
            isinstance(available_attacks[cmd], list) and \
            not isinstance(available_attacks[cmd][0], dict):
            # Execute the attack!
            try:
                getattr(import_module(f"modules.{cmd}.{cmd}"), f"perform_{cmd}_attack")(sub_cmd)
            except KeyboardInterrupt as e:
                print ("\n[*] Stopping the attack...\n")

        elif isinstance(available_attacks[cmd], dict) and \
            sub_cmd in available_attacks[cmd] and \
            sub_sub_cmd in available_attacks[cmd][sub_cmd]:
            prompt = f"[{cmd}/{sub_cmd}/{sub_sub_cmd}]"

        elif isinstance(available_attacks[cmd], list) and \
            isinstance(available_attacks[cmd][0], dict) and \
            sub_sub_cmd in exists_in_attack_module(available_attacks[cmd], sub_cmd):
            prompt = f"[{cmd}/{sub_cmd}/{sub_sub_cmd}]"

        else:
            if unconsumed_parts[0] == "list":
                print ("\n[*] Available sub-commands:")
            else:
                print (f"\n[-] Invalid sub-command specified: {unconsumed_parts[0]}\n")

            if isinstance(available_attacks[cmd], dict) and \
            sub_cmd in available_attacks[cmd]:
                list_available_items(available_attacks[cmd][sub_cmd])
                list_available_general_commands()

            elif isinstance(available_attacks[cmd][0], dict):
                sub_attacks = exists_in_attack_module(available_attacks[cmd], sub_cmd)

                if sub_attacks:
                    list_available_items(sub_attacks)

                list_available_general_commands()

            else:
                list_available_general_commands(with_header = False)


    elif len(unconsumed_parts) == 2 and \
        (isinstance(available_attacks[cmd], dict) or \
        isinstance(available_attacks[cmd][0], dict)):

        sub_sub_cmd = unconsumed_parts[0].lower()
        unconsumed_parts = [_.lower() for _ in unconsumed_parts[1:]]

        if unconsumed_parts[0] in ["help", "info"]:

            if isinstance(available_attacks[cmd], list) and \
                sub_cmd in available_attacks[cmd] and \
                isinstance(available_attacks[cmd][sub_cmd], list) and \
                sub_sub_cmd in available_attacks[cmd][sub_cmd]:
                print ("\nAvailable sub-commands:")
                list_available_items(available_attacks[cmd][sub_cmd][sub_sub_cmd])
                list_available_general_commands()

            else:
                print ("\nInformation:")
                print (getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"{sub_sub_cmd}_help")())


        elif unconsumed_parts[0] in ["run", "exploit"]:
            # Execute the attack!
            try:
                getattr(import_module(f"modules.{cmd}.{sub_cmd}"), f"perform_{sub_cmd}_attack")(sub_sub_cmd)
            except KeyboardInterrupt as e:
                print ("\n[*] Stopping the attack...\n")

        else:

            if unconsumed_parts[0] == "list":
                print ("\n[*] Available sub-commands:")
            else:
                print (f"\n[-] Invalid sub-command specified: {unconsumed_parts[0]}\n")

            if isinstance(available_attacks[cmd], list) and \
            sub_cmd in available_attacks[cmd] and \
            isinstance(available_attacks[cmd][sub_cmd], list) and \
            sub_sub_cmd in available_attacks[cmd][sub_cmd]:
                list_available_items(available_attacks[cmd][sub_cmd])
                list_available_general_commands()

            else:
                list_available_general_commands(with_header = False)


    else:
        if sub_cmd in available_attacks[cmd]:
            print (f"\n[-] Invalid sub-command specified for `{cmd} {sub_cmd}`.")
            list_available_general_commands()

        else:
            print (f"\n[-] Invalid sub-command specified: {sub_cmd}\n\n[*] Available sub-commands:")
            list_available_items(available_attacks[cmd])
            list_available_general_commands()

    return prompt



def launch_in_interactive_mode():

    print("\nTo get help, enter `help`.")
    print("To get help on a specific module, enter `help <Module Name>`.\n")

    prompt = ""
    prompt_sign = ">"

    while True:
        try:
            unconsumed_parts = shlex.split(input(f"{prompt}{prompt_sign} "), posix = False)
        except KeyboardInterrupt as e:
            sys.exit(0)
        except Exception as e:
            sys.exit(0)


        # Handle commands like shell, redis-shell
        if len(unconsumed_parts) > 0:
            if unconsumed_parts[0] in ["shell", "sh"]:
                unconsumed_parts = unconsumed_parts[1:]
                prompt_sign = "$"

            elif unconsumed_parts[0] in ["redis-shell", "rsh"]:
                unconsumed_parts = unconsumed_parts[1:]
                prompt_sign = REDIS_PROMPT

        # Handle shell commands
        if prompt_sign == "$":
            if len(unconsumed_parts) == 0:
                continue

            prompt_sign = handle_shell_command(unconsumed_parts, prompt_sign)
            continue

        # Handle redis commands
        elif prompt_sign == REDIS_PROMPT:
            if len(unconsumed_parts) == 0:
                continue

            prompt_sign = handle_redis_command(unconsumed_parts, prompt_sign)
            continue

        if len(unconsumed_parts) == 0:
            continue

        unconsumed_parts[0] = unconsumed_parts[0].lower()

        # Handle exit family of commands
        if unconsumed_parts[0] in ["exit", "quit", "bye"]:
            break

        # reset the prompt to very beginning (moves out of all the modules)
        elif unconsumed_parts[0] == "reset":
            prompt = ""
            continue

        # Move up the module/attack heirarchy
        # A number can be specified to move that many levels up
        elif unconsumed_parts[0] in ["back", "up"]:
            up_count = 1
            if len(unconsumed_parts) > 1:
                try:
                    up_count = int(unconsumed_parts[1])
                except:
                    pass
            prompt = adjust_prompt_level(prompt, up_count)
            continue

        # If prompt already is set to some value
        # meaning we are in some module/attack heirachy
        # then we need to get those values in unconsumed_parts
        # to get to the specific attack module/sub-module
        if prompt != "":
            module_hierarchy = prompt[1:-1].split("/")
            cmd = module_hierarchy[0]
            if len(module_hierarchy) > 1:
                unconsumed_parts = module_hierarchy[1:] + unconsumed_parts

        # No attack is set, we are just starting out...
        else:
            cmd = unconsumed_parts[0]
            unconsumed_parts = unconsumed_parts[1:]

        # Handle help/info/list
        if cmd in ["help", "info", "list"]:
            # Length would give the unconsumed unconsumed_parts
            if len(unconsumed_parts) == 0:
                list_available_general_commands()

                print ("\n[*] Available attack modules:")
                list_available_items(AVAILABLE_ATTACK_MODULES)

                print("\nEnter the module name to proceed: \n")

            # A module name is entered
            elif len(unconsumed_parts) == 1:
                sub_cmd = unconsumed_parts[0]
                sub_cmd = sub_cmd.lower()

                # show info on the sub_cmd
                if sub_cmd in AVAILABLE_ATTACK_MODULES:
                    print (get_attack_module_help_message(sub_cmd))

                else:
                    print (f"\n[-] Invalid module name specified: {sub_cmd}\n")
                    print ("\n[*] Available attack modules:")
                    list_available_items(AVAILABLE_ATTACK_MODULES)

            else:
                print ("\n[-] Unexpected number of arguments:")
                print ("Use `help` or `info` to list all the available modules.")
                print ("Use `help <Module Name>` or `info <Module Name>` to get info about the specified module.\n")
                print ("[*] Available modules:")
                print ("\n[*] Available attack modules:")
                list_available_general_commands()


        # A module name was entered,
        # we will switch to it
        elif cmd in AVAILABLE_ATTACK_MODULES:
            available_attacks = import_module(f"modules.{cmd}").AVAILABLE_ATTACKS
            prompt = handle_attack_sub_commands(cmd, unconsumed_parts, prompt, available_attacks)

        # Some invalid command was provided...
        else:
            print(f"\n[-] Invalid command/module name specified: {cmd}\n")

            print ("\n[*] Available attack modules:")
            list_available_items(AVAILABLE_ATTACK_MODULES)

            list_available_general_commands()



if __name__ == "__main__":
    launch_in_interactive_mode()