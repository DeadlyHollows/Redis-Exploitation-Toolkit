from importlib import import_module

from pprint import pprint
from pkgutil import iter_modules

import readline
import shlex
import sys
from os import getlogin, get_terminal_size

from common import handle_ret_framework_commands, \
        list_available_general_commands, list_available_items

from helper.utils import execute_command_with_output, \
        execute_redis_command, strip_quotes_from_entries



RET_FRAMEWORK_PROMPT = ">>>"
REDIS_SHELL_PROMPT = "{redis}>"
OS_SHELL_PROMPT = f"{{{getlogin()}}}$"


# TODO: Move it out of here...
AVAILABLE_ATTACK_MODULES = [name for _, name, _ in iter_modules(["modules"])]

# The max path that is matched by `parse_attack_module_commands` function.
MAX_MATCH_ATTACK_PATH = []

# The remaining path that we can refer to, to apply further commands.
SUBSEQUENT_AVAILABLE_ATTACK_PATH = []



def handle_shell_command(unconsumed_parts, prompt_sign):

    if unconsumed_parts[0] in ["exit", "quit"]:
        prompt_sign = RET_FRAMEWORK_PROMPT
        print ()

        return prompt_sign

    # Hand it over to the shell.
    output = execute_command_with_output(" ".join(unconsumed_parts))
    print (output.decode(encoding = "utf-8", errors = "replace"))
    return prompt_sign



def handle_redis_command(unconsumed_parts, prompt_sign):

    if unconsumed_parts[0] in ["exit", "quit"]:
        prompt_sign = RET_FRAMEWORK_PROMPT
        print ()

        return prompt_sign

    # Run Redis command.
    try:
        unconsumed_parts = strip_quotes_from_entries(unconsumed_parts)
        output = execute_redis_command(*unconsumed_parts)

        if isinstance(output, str):
            print ()
            print (output)
        else:
            pprint(output, width = (get_terminal_size().columns * 9) // 10, compact = True)

    except Exception as e:
        print (e)

    print ()

    return prompt_sign



def parse_attack_module_commands(specified_command, comsumed_command_idx,
        current_exploration_path, available_attack_paths):

    # Parse the attack module path until:
    # - it ends within an existing path
    # - it ends with an exploit/run command after the existing path
    # - it has a partial correct path
    # - it with help/info/list

    # comsumed_command_idx: Attack module path (in the specified command) that is
    # consumed till now.

    global MAX_MATCH_ATTACK_PATH, SUBSEQUENT_AVAILABLE_ATTACK_PATH

    if comsumed_command_idx == len(specified_command):
        # Path found, stop search!
        return (specified_command, comsumed_command_idx, current_exploration_path,
                available_attack_paths)

    for attack_path in available_attack_paths:

        if isinstance(attack_path, str) and \
            attack_path == specified_command[comsumed_command_idx]:

            if isinstance(available_attack_paths, dict):

                if comsumed_command_idx + 1 > len(MAX_MATCH_ATTACK_PATH):
                    MAX_MATCH_ATTACK_PATH.append(attack_path)
                    SUBSEQUENT_AVAILABLE_ATTACK_PATH = available_attack_paths[attack_path]

                res = parse_attack_module_commands(specified_command,
                        comsumed_command_idx + 1, current_exploration_path + [attack_path],
                        available_attack_paths[attack_path])

                if res and res[1] == len(res[0]):
                    # Path found, stop search!
                    return res

            else:
                # Available paths to go!
                if comsumed_command_idx + 1 > len(MAX_MATCH_ATTACK_PATH):
                    MAX_MATCH_ATTACK_PATH.append(attack_path)
                    SUBSEQUENT_AVAILABLE_ATTACK_PATH = []

                if (comsumed_command_idx + 1) == len(specified_command):
                    # Path found, stop search!
                    return (specified_command, comsumed_command_idx + 1,
                            current_exploration_path, attack_path)


        elif isinstance(attack_path, dict):
            res = parse_attack_module_commands(specified_command, comsumed_command_idx,
                    current_exploration_path, attack_path)

            if res[1] == len(res[0]):
                # Path found, stop search!
                return res

    return (specified_command, comsumed_command_idx, current_exploration_path,
            available_attack_paths)



def get_normalized_prompt(prompt):
    if prompt != "":
        prompt = f"[{prompt}]"

    return prompt



def adjust_prompt_level(prompt, level):

    if level == -1:
        # Reset the prompt
        prompt = ""

    else:
        prompt = "/".join(prompt[1:-1].split("/")[:-level])

    return get_normalized_prompt(prompt)



def launch_in_interactive_mode():

    print("\nTo get help, enter `help`.")
    print("To get help on a specific module, enter `help <Module Name>`.\n")

    prompt = ""
    prompt_sign = RET_FRAMEWORK_PROMPT

    global MAX_MATCH_ATTACK_PATH, SUBSEQUENT_AVAILABLE_ATTACK_PATH

    while True:
        try:
            unconsumed_parts = shlex.split(input(f"{prompt}{prompt_sign} "), posix = False)
        except KeyboardInterrupt as e:
            sys.exit(0)
        except Exception as e:
            sys.exit(0)

        # The framework is case-insensitive.
        unconsumed_parts = [ part.lower() for part in unconsumed_parts ]

        # Handle commands like shell, redis-shell
        if len(unconsumed_parts) > 0:
            if unconsumed_parts[-1] in ["shell", "sh"]:
                unconsumed_parts = unconsumed_parts[1:]
                prompt_sign = OS_SHELL_PROMPT
                print ()

            elif unconsumed_parts[-1] in ["redis-shell", "rsh"]:
                unconsumed_parts = unconsumed_parts[1:]
                prompt_sign = REDIS_SHELL_PROMPT
                print ()

        # Handle shell commands
        if prompt_sign == OS_SHELL_PROMPT:
            if len(unconsumed_parts) == 0:
                continue

            prompt_sign = handle_shell_command(unconsumed_parts, prompt_sign)
            continue

        # Handle redis commands
        elif prompt_sign == REDIS_SHELL_PROMPT:
            if len(unconsumed_parts) == 0:
                continue

            prompt_sign = handle_redis_command(unconsumed_parts, prompt_sign)
            continue

        if len(unconsumed_parts) == 0:
            continue

        # Handle exit family of commands
        if unconsumed_parts[-1] in ["exit", "quit", "bye"]:
            break

        elif unconsumed_parts[-1] == "reset":
            prompt = adjust_prompt_level(prompt, -1)

            MAX_MATCH_ATTACK_PATH = []
            SUBSEQUENT_AVAILABLE_ATTACK_PATH = []

            continue

        # Move up the module/attack heirarchy
        # A number can be specified to move that many levels up
        # To reset the prompt to very beginning (moves out of all the modules)
        # use the up_count value of -1
        elif unconsumed_parts[0] in ["back", "up"]:

            MAX_MATCH_ATTACK_PATH = []
            SUBSEQUENT_AVAILABLE_ATTACK_PATH = []

            up_count = 1

            if len(unconsumed_parts) > 1:
                try:
                    up_count = int(unconsumed_parts[1])
                except:
                    pass

            prompt = adjust_prompt_level(prompt, up_count)

            continue


        # If prompt already is set to some value
        # meaning we are in some module/attack heirachy
        # then we need to get those values in unconsumed_parts
        # to get to the specific attack module/sub-module

        if prompt != "":
            current_attack_module_path = prompt[1:-1].split("/")

            unconsumed_parts = current_attack_module_path + unconsumed_parts

            if SUBSEQUENT_AVAILABLE_ATTACK_PATH or MAX_MATCH_ATTACK_PATH:
                # We start out from the path in the prompt
                MAX_MATCH_ATTACK_PATH = current_attack_module_path
                available_attack_paths = SUBSEQUENT_AVAILABLE_ATTACK_PATH

            else:
                # prompt = ""
                available_attack_paths = getattr(import_module("modules"), "AVAILABLE_ATTACKS")
                MAX_MATCH_ATTACK_PATH = []
                SUBSEQUENT_AVAILABLE_ATTACK_PATH = available_attack_paths

        else:
            available_attack_paths = getattr(import_module("modules"), "AVAILABLE_ATTACKS")
            MAX_MATCH_ATTACK_PATH = []
            SUBSEQUENT_AVAILABLE_ATTACK_PATH = available_attack_paths


        # An attack name was entered, we will
        # switch to the relevant modules...

        specified_command = unconsumed_parts
        
        # The path explored during recursive search
        current_exploration_path = []

        # `MAX_MATCH_ATTACK_PATH` contains the path matched in the available
        # attack path. 
        # So we can be sure that that much path is present in the command.

        if available_attack_paths:
            parse_attack_module_commands(specified_command, len(MAX_MATCH_ATTACK_PATH),
                    current_exploration_path, available_attack_paths)

            consumed_command_idx = len(MAX_MATCH_ATTACK_PATH)

            remaining_commands = specified_command[consumed_command_idx:]

            if len(remaining_commands) > 0:
                handle_ret_framework_commands(remaining_commands, MAX_MATCH_ATTACK_PATH, \
                        SUBSEQUENT_AVAILABLE_ATTACK_PATH)

                MAX_MATCH_ATTACK_PATH = []
                SUBSEQUENT_AVAILABLE_ATTACK_PATH = []

            else:
                prompt = get_normalized_prompt("/".join(MAX_MATCH_ATTACK_PATH))

                if prompt == "":
                    print ("\n[*] Available modules:")

                # We have more paths but no extra command/module paths are specified.
                elif len(SUBSEQUENT_AVAILABLE_ATTACK_PATH) > 0:
                    if isinstance(SUBSEQUENT_AVAILABLE_ATTACK_PATH[0], dict):
                        print ("\n[*] Available sub-modules:")

                    else:
                        print ("\n[*] Available attacks:")

                # We have no more paths and no extra command/module paths are specified.
                elif len(SUBSEQUENT_AVAILABLE_ATTACK_PATH) == 0:
                    # No command left...
                    # List the available general commands
                    list_available_general_commands()

                list_available_items(SUBSEQUENT_AVAILABLE_ATTACK_PATH)

        else:
            consumed_command_idx = len(MAX_MATCH_ATTACK_PATH)
            remaining_commands = specified_command[consumed_command_idx:]

            handle_ret_framework_commands(remaining_commands, MAX_MATCH_ATTACK_PATH, \
                    SUBSEQUENT_AVAILABLE_ATTACK_PATH)



if __name__ == "__main__":
    launch_in_interactive_mode()