# Contains common functions used by both automated and
# interactive modes.
from importlib import import_module
from sys import exit
import redis.exceptions as exceptions

from helper.connection import get_next_cached_db_conntection



def list_available_items(items, add_newline = True):

    idx = 1
    for item in items:
        if isinstance(item, dict):
            print(f"{idx} - {list(item.keys())[0]}")
        else:
            print(f"{idx} - {item}")
        idx += 1

    # If we iterate, only then print a newline
    # else it just adds extra newlines which is
    # not required.
    if idx != 1 and add_newline:
        print()



def list_available_general_commands(with_header = True):

    if with_header:
        print("\n[*] Available general commands:")

    print("- help / info")
    print("- list")
    print("- run / exploit")
    print("- shell / sh")
    print("- redis-shell / rsh")
    print("- back <N> / up <N>")
    print("- reset\n")



def launch_exploit(attack_path):
    print("\n=====>" , "Performing", "/".join(attack_path), "<=====")

    redis = None

    while True:

        redis = get_next_cached_db_conntection(redis)

        if redis == None:
            # either no more conns left or invalid conn is provided!
            break

        try:
            # TODO: Get the attack response and determine if the next attack should be
            # executed or not!
            getattr(import_module("modules." + ".".join(attack_path[:-1])), \
                    attack_path[-1])(redis)

        except exceptions.NoPermissionError as e:
            # User didn't had permissions to execute the attack.
            # Switching the cached Redis instance!
            print(e)
            # print("[*] Switching connection...")
            continue

        except exceptions.ConnectionError as e:
            print("\n[-]", e, "\n")

        except KeyboardInterrupt:
            print("\n\n[*] Skipping the attack.\n")

        except EOFError:
            print("\n\nExiting...")
            exit(-1)

        except Exception as e:
            print(e)

        break



# Handles the remaining commands specified after the module/
# sub-module/attack path.
def handle_ret_framework_commands(commands, attack_path,
        available_attack_paths = []):

            # Possibilities:
            # - help
            # - info / list
            # - run / exploit
            # - invalid command!

            extra_cmds_count = len(commands)

            if extra_cmds_count == 0:
                # No extra commands specified...
                list_available_general_commands()

            elif extra_cmds_count == 1:
                # handle_ret_framework_command()
                cmd = commands[0]

                if cmd in [ "run", "exploit" ]:
                    # Check if exploit command is valid at this level!
                    if not available_attack_paths:
                        # Launch the exploit module...
                        launch_exploit(attack_path)

                    else:
                        print("\n[-] Kindly select an attack for exploitation to begin.\n")

                elif cmd in ["help", "info"]:
                    # Show help/info on the selected module/sub-module/attack
                    attack_module_path = ["modules"] + attack_path

                    if len(attack_module_path) == 1:
                        # "modules"
                        attack_module_path.append("modules")

                    help_msg = getattr(import_module(".".join(attack_module_path[:-1])),
                            f"{attack_module_path[-1]}_help")()

                    print("\n[*] Information:", help_msg, end = "\n")

                    """
                    # Contains list of available modules/commands as well
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        list_available_items(available_attack_paths)
                    """

                elif cmd == "list":
                    # List command
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        print("\n[*] Available commands:")
                        list_available_items(available_attack_paths)

                else:
                    # Invalid command
                    print(f"\n[-] Invalid command: {cmd}")
                    print("\n[*] Available commands:")
                    list_available_items(available_attack_paths, add_newline = False)
                    list_available_general_commands()


            else:
                # Probably extra commands are specified...
                print(f"\n[-] Expected zero/one commands, got {extra_cmds_count}:",
                        " ".join(commands))

                print("\n[*] Available Commands:")
                list_available_items(available_attack_paths, add_newline = False)
                list_available_general_commands()