# Contains common functions used by both automated and
# interactive modes.
from sys import exit
from importlib import import_module

from helper.connection import get_next_cached_db_conntection

import redis.exceptions as exceptions



def list_available_items(items, add_newline = True):

    idx = 1
    for item in items:
        if isinstance(item, dict):
            print(f"{idx} - {list(item.keys())[0]}")
        else:
            print(f"{idx} - {item}")
        idx += 1

    # If we iterate, only then print a newline
    # else it just adds extra newlines which is
    # not required.
    if idx != 1 and add_newline:
        print()



def list_available_general_commands(with_header = True):

    if with_header:
        print("\n[*] Available general commands:")

    print("- help / info")
    print("- list")
    print("- run / exploit")
    print("- shell / sh")
    print("- redis-shell / rsh")
    print("- back <N> / up <N>")
    print("- reset\n")



def get_launch_attack_sequence(attack_path, dependency_sequence):

    sequence = dependency_sequence.copy()

    for path in attack_path:

        if isinstance(sequence, dict):
            sequence = sequence[path]

        elif isinstance(sequence, list):
            for attack in sequence:
                # print ("attack:", attack, "\n")
                if list(attack.keys())[0] == path:
                    sequence = attack[path]
                    break

    launch_attack_sequence = {}

    if "depends_on" in sequence and "expected_results" in sequence:

        for (dependent_attack, expected_result) in \
                zip(sequence["depends_on"], sequence["expected_results"]):

            # dependent_attack_path = dependent_attack.split("/")
            # print(dependent_attack, expected_result)

            if dependent_attack.count("/") == 0:
                # 1 item
                normalized_dependent_attack_path = "/".join(attack_path[:-1]) + "/" + dependent_attack

            else:
                normalized_dependent_attack_path = dependent_attack

            launch_attack_sequence[normalized_dependent_attack_path] = expected_result


    # We don't care about the response of this attack,
    # so specifying 'ANY'
    launch_attack_sequence["/".join(attack_path)] = "ANY"

    return launch_attack_sequence



def launch_exploit(attack_path):
    print("\n=====>" , "Performing", "/".join(attack_path), "<=====")

    redis = None

    while True:

        redis = get_next_cached_db_conntection(redis)

        if redis == None:
            # either no more conns left or invalid conn is provided!
            break

        try:
            # TODO: Get the attack response and determine if the next attack should be
            # executed or not!
            getattr(import_module("modules." + ".".join(attack_path[:-1])), \
                    attack_path[-1])(redis)

        except exceptions.NoPermissionError as e:
            # User didn't had permissions to execute the attack.
            # Switching the cached Redis instance!
            print(e)
            # print("[*] Switching connection...")
            continue

        except exceptions.ConnectionError as e:
            print("\n[-]", e, "\n")

        except KeyboardInterrupt:
            print("\n\n[*] Skipping the attack.\n")

        except EOFError:
            print("\n\nExiting...")
            exit(-1)

        except AttributeError as e:
            print("\n[-] No such attack exists!\n")

        except Exception as e:
            print(e.__class__)
            print(e)

        break



# Handles the remaining commands specified after the module/
# sub-module/attack path.
def handle_ret_framework_commands(commands, attack_path,
        available_attack_paths = []):

            # Possibilities:
            # - help
            # - info / list
            # - run / exploit
            # - invalid command!

            extra_cmds_count = len(commands)

            if extra_cmds_count == 0:
                # No extra commands specified...
                list_available_general_commands()

            elif extra_cmds_count == 1:
                # handle_ret_framework_command()
                cmd = commands[0]

                if cmd in [ "run", "exploit" ]:
                    # Check if exploit command is valid at this level!
                    if not available_attack_paths:
                        # Launch the exploit module...
                        launch_exploit(attack_path)

                    else:
                        print("\n[-] Kindly select an attack for exploitation to begin.\n")

                elif cmd in ["help", "info"]:
                    # Show help/info on the selected module/sub-module/attack
                    attack_module_path = ["modules"] + attack_path

                    if len(attack_module_path) == 1:
                        # "modules"
                        attack_module_path.append("modules")

                    help_msg = getattr(import_module(".".join(attack_module_path[:-1])),
                            f"{attack_module_path[-1]}_help")()

                    print("\n[*] Information:", help_msg, end = "\n")

                    """
                    # Contains list of available modules/commands as well
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        list_available_items(available_attack_paths)
                    """

                elif cmd == "list":
                    # List command
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        print("\n[*] Available commands:")
                        list_available_items(available_attack_paths)

                else:
                    # Invalid command
                    print(f"\n[-] Invalid command: {cmd}")
                    print("\n[*] Available commands:")
                    list_available_items(available_attack_paths, add_newline = False)
                    list_available_general_commands()


            else:
                # Probably extra commands are specified...
                print(f"\n[-] Expected zero/one commands, got {extra_cmds_count}:",
                        " ".join(commands))

                print("\n[*] Available Commands:")
                list_available_items(available_attack_paths, add_newline = False)
                list_available_general_commands()