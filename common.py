# Contains common functions used by both automated and interactive modes.
from importlib import import_module



def list_available_items(items, add_newline = True):

    idx = 1
    for item in items:
        if isinstance(item, dict):
            print (f"{idx} - {list(item.keys())[0]}")
        else:
            print (f"{idx} - {item}")
        idx += 1

    # If we iterate, only then print a newline
    # else it just adds extra newlines which is
    # not required.
    if idx != 1 and add_newline:
        print ()



def list_available_general_commands(with_header = True):

    if with_header:
        print ("\n[*] Available general commands:")

    print ("- help")
    print ("- info / list")
    print ("- run / exploit")
    print ("- shell / sh")
    print ("- redis-shell / rsh")
    print ("- back <N> / up <N>")
    print ("- reset\n")



# Handles the remaining commands specified after the module/sub-module/attack path.
def handle_ret_framework_commands(commands, attack_path, available_attack_paths = []):

            # Possibilities:
            # - help
            # - info / list
            # - run / exploit
            # - invalid command!

            # print ("commands:", commands)
            # print ("attack_path:", attack_path)

            extra_cmds_count = len(commands)

            if extra_cmds_count == 0:
                # No extra commands specified...
                list_available_general_commands()

            elif extra_cmds_count == 1:
                # handle_ret_framework_command()
                cmd = commands[0]

                if cmd in [ "run", "exploit" ]:
                    # Launch the exploit module...
                    getattr(import_module("modules." + ".".join(attack_path[:-1])),
                            attack_path[-1])()

                elif cmd == "help":
                    # Show help on the selected module/sub-module/attack
                    attack_module_path = ["modules"] + attack_path
                    help_msg = getattr(import_module(".".join(attack_module_path[:-1])),
                            f"{attack_module_path[-1]}_help")()

                    print ("\n[*] Information:", help_msg, end = "\n")

                    """
                    # Contains list of available modules/commands as well
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        list_available_items(available_attack_paths)
                    """

                elif cmd == "info":
                    # Show info on the selected module/sub-module/attack
                    pass

                elif cmd == "list":
                    # List command
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        # print ("available_attack_paths:", available_attack_paths)

                        print ("\n[*] Available commands:")
                        list_available_items(available_attack_paths)

                else:
                    # Invalid command
                    print (f"\n[-] Invalid command: {cmd}")
                    print ("\n[*] Available commands:")
                    list_available_items(available_attack_paths, add_newline = False)
                    list_available_general_commands()


            else:
                # Probably extra commands are specified...
                print (f"[-] Expected zero/one commands, got {extra_cmds_count}: ",
                        " ".join(commands))

                list_available_general_commands()