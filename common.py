# Contains common functions used by both automated and
# interactive modes.
from importlib import import_module
from sys import exit



def list_available_items(items, add_newline = True):

    idx = 1
    for item in items:
        if isinstance(item, dict):
            print (f"{idx} - {list(item.keys())[0]}")
        else:
            print (f"{idx} - {item}")
        idx += 1

    # If we iterate, only then print a newline
    # else it just adds extra newlines which is
    # not required.
    if idx != 1 and add_newline:
        print ()



def list_available_general_commands(with_header = True):

    if with_header:
        print ("\n[*] Available general commands:")

    print ("- help / info")
    print ("- list")
    print ("- run / exploit")
    print ("- shell / sh")
    print ("- redis-shell / rsh")
    print ("- back <N> / up <N>")
    print ("- reset\n")



def launch_exploit(attack_path):
    print ("\n=====>" , "Performing", "/".join(attack_path), "<=====")

    try:
        getattr(import_module("modules." + ".".join(attack_path[:-1])), \
                attack_path[-1])()

    except KeyboardInterrupt:
        print ("\n\n[*] Skipping the attack.\n")

    except EOFError:
        print ("\n\nExiting...")
        exit(-1)



# Handles the remaining commands specified after the module/
# sub-module/attack path.
def handle_ret_framework_commands(commands, attack_path,
        available_attack_paths = []):

            # Possibilities:
            # - help
            # - info / list
            # - run / exploit
            # - invalid command!

            extra_cmds_count = len(commands)

            if extra_cmds_count == 0:
                # No extra commands specified...
                list_available_general_commands()

            elif extra_cmds_count == 1:
                # handle_ret_framework_command()
                cmd = commands[0]

                if cmd in [ "run", "exploit" ]:
                    # Check if exploit command is valid at this level!
                    if not available_attack_paths:
                        # Launch the exploit module...
                        launch_exploit(attack_path)

                    else:
                        print ("\n[-] Kindly select an attack for exploitation to begin.\n")

                elif cmd in ["help", "info"]:
                    # Show help/info on the selected module/sub-module/attack
                    attack_module_path = ["modules"] + attack_path

                    if len(attack_module_path) == 1:
                        # "modules"
                        attack_module_path.append("modules")

                    help_msg = getattr(import_module(".".join(attack_module_path[:-1])),
                            f"{attack_module_path[-1]}_help")()

                    print ("\n[*] Information:", help_msg, end = "\n")

                    """
                    # Contains list of available modules/commands as well
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        list_available_items(available_attack_paths)
                    """

                elif cmd == "list":
                    # List command
                    if not available_attack_paths:
                        list_available_general_commands()
                    else:
                        print ("\n[*] Available commands:")
                        list_available_items(available_attack_paths)

                else:
                    # Invalid command
                    print (f"\n[-] Invalid command: {cmd}")
                    print ("\n[*] Available commands:")
                    list_available_items(available_attack_paths, add_newline = False)
                    list_available_general_commands()


            else:
                # Probably extra commands are specified...
                print (f"\n[-] Expected zero/one commands, got {extra_cmds_count}:",
                        " ".join(commands))

                print ("\n[*] Available Commands:")
                list_available_items(available_attack_paths, add_newline = False)
                list_available_general_commands()